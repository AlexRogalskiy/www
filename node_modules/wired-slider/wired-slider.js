import { LitElement, html } from '@polymer/lit-element/lit-element.js';
import { wired } from 'wired-lib/wired-lib.js';

export class WiredSlider extends LitElement {
  static get properties() {
    return {
      value: Number,
      min: Number,
      max: Number,
      knobradius: Number,
      disabled: Boolean
    };
  }

  constructor() {
    super();
    this.disabled = false;
    this.value = 0;
    this.min = 0;
    this.max = 100;
    this.knobradius = 10;
    this.classList.add('pending');

    this._upHandler = this._mouseup.bind(this);
    this._moveHandler = this._mousemove.bind(this);
  }

  _render() {
    this._onDisableChange();
    return html`
    <style>
      :host {
        display: inline-block;
        position: relative;
        width: 300px;
        height: 40px;
        box-sizing: border-box;
      }
    
      :host(.disabled) {
        opacity: 0.45 !important;
        cursor: default;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.07);
        border-radius: 5px;
      }
    
      :host(.disabled) .knob {
        pointer-events: none !important;
      }
    
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
      }
    
      svg {
        display: block;
      }
    
      path {
        stroke-width: 0.7;
        fill: transparent;
      }
    
      .knob {
        pointer-events: auto;
        fill: var(--wired-slider-knob-zero-color, gray);
        stroke: var(--wired-slider-knob-zero-color, gray);
        transition: transform 0.15s ease;
        cursor: pointer;
      }
    
      .hasValue {
        fill: var(--wired-slider-knob-color, rgb(51, 103, 214));
        stroke: var(--wired-slider-knob-color, rgb(51, 103, 214));
      }
    
      .bar {
        stroke: var(--wired-slider-bar-color, rgb(0, 0, 0));
      }
    
      .expanded {
        transform: scale(1.3) translate(-15%, -15%);
      }
    
      :host(.pending) {
        opacity: 0;
      }
    </style>
    <div class="overlay">
      <svg id="svg"></svg>
    </div>
    `;
  }

  _onDisableChange() {
    if (this.disabled) {
      this.classList.add("disabled");
    } else {
      this.classList.remove("disabled");
    }
  }

  _clearNode(node) {
    while (node.hasChildNodes()) {
      node.removeChild(node.lastChild);
    }
  }

  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => this._firstRendered(), 100);
  }

  _firstRendered() {
    const svg = this.shadowRoot.getElementById('svg');
    this._clearNode(svg);
    const s = this.getBoundingClientRect();
    svg.setAttribute("width", s.width);
    svg.setAttribute("height", s.height);
    let radius = this.knobradius || 10;
    this._barWidth = s.width - (2 * radius);
    this._bar = wired.line(svg, radius, s.height / 2, s.width - radius, s.height / 2);
    this._bar.classList.add("bar");
    this._knobGroup = wired._svgNode("g");
    svg.appendChild(this._knobGroup);
    this._knob = wired.ellipse(this._knobGroup, radius, s.height / 2, radius * 2, radius * 2);
    this._knob.classList.add("knob");
    this._onValueChange();
    this.classList.remove('pending');

    this._knob.addEventListener('mousedown', (event) => {
      if (!this.disabled)
        this._mousedown(event);
    });

    this._knob.addEventListener('dragstart', () => {
      return false;
    });
  }

  _onValueChange() {
    if (!this._knob) {
      return;
    }
    let pct = 0;
    if (this.max > this.min) {
      pct = Math.min(1, Math.max((this.value - this.min) / (this.max - this.min), 0));
    }
    this._pct = pct;
    if (pct) {
      this._knob.classList.add("hasValue");
    } else {
      this._knob.classList.remove("hasValue")
    }
    let knobOffset = pct * this._barWidth;
    this._knobGroup.style.transform = "translateX(" + Math.round(knobOffset) + "px)";
    this._knobOffset = knobOffset;
  }

  _mousedown(event) {
    event.preventDefault();
    const offset = this._knob.getBoundingClientRect().left > this._knobOffset ? this._knob.getBoundingClientRect().left : (this._knob.getBoundingClientRect().left + this._knobOffset);
    this.shiftX = event.clientX - offset;
    document.addEventListener('mousemove', this._moveHandler);
    document.addEventListener('mouseup', this._upHandler);
    this._mouseMoved = false;
  }

  _mousemove(event) {
    this._mouseMoved = true;
    let newLeft = event.clientX - this.shiftX - this.getBoundingClientRect().left;
    if (newLeft < 0) {
      newLeft = 0;
    }
    let rightEdge = this.offsetWidth - 20;
    if (newLeft > rightEdge) {
      newLeft = rightEdge;
    }
    this._intermediateRatio = newLeft / rightEdge;
    this._knobGroup.style.transform = "translateX(" + Math.round(newLeft) + "px)";
  }

  _mouseup(event) {
    document.removeEventListener('mousemove', this._moveHandler);
    document.removeEventListener('mouseup', this._upHandler);
    if (this._mouseMoved) {
      this.value = this.min + this._intermediateRatio * (this.max - this.min);
      this._onValueChange();
      const ev = new CustomEvent('change', { bubbles: true, composed: true, detail: { value: this.value } });
      this.dispatchEvent(ev);
    }
  }
}
customElements.define('wired-slider', WiredSlider);